<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fretboar V2</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<div class="controls">
  <label>
    Tuning: <input id="tuningInput" type="text" value="E A D G B E" />
  </label>
  <label>
    Frets: <input id="fretsInput" type="number" value="24" min="1" max="30" />
  </label>
  <label>
    Highlight Notes: <input id="notesInput" type="text" value="" />
  </label>
  <label>
    Scale Root:
    <select id="scaleRootSelect"></select>
  </label>
  <label>
    <input type="checkbox" id="highlightRootToggle" /> Highlight Root Note
  </label>
  <label>
    Scale:
    <select id="scaleSelect"></select>
  </label>
  <label>
    <input type="checkbox" id="hideNonMatchingToggle" checked /> Hide Non-Matching Notes
  </label>
</div>

<div class="fretboard-wrapper">
  <div class="fretboard" id="fretboard"></div>
  <div class="labels" id="labels"></div>
</div>
<div id="analysisOutput">Select notes to see matching scales.</div>

<script src="scales.js"></script> 
<script>
const scales = Object.fromEntries(window.scaleDefs);
const noteMap = {
  "C": 0, "C#": 1, "DB": 1, "D": 2, "D#": 3, "EB": 3,
  "E": 4, "FB": 4, "F": 5, "F#": 6, "GB": 6,
  "G": 7, "G#": 8, "AB": 8, "A": 9, "A#": 10, "BB": 10, "B": 11, "CB": 11
};
const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

function getNoteName(i) {
  return noteNames[i % 12];
}

function parseNotes(input) {
  return input.toUpperCase().split(/[\s,]+/)
    .map(n => noteMap[n] != null ? getNoteName(noteMap[n]) : null)
    .filter(Boolean);
}

function populateSelectors() {
  const rootSelect = document.getElementById('scaleRootSelect');
  rootSelect.innerHTML = "<option></option>" + noteNames.map(n => `<option>${n}</option>`).join('');
  
  const scaleSelect = document.getElementById('scaleSelect');
  scaleSelect.innerHTML = `<option value="">--None--</option>` + window.scaleDefs.map(
    ([name]) => `<option value="${name}">${name}</option>`
  ).join('');
}

function getScaleNotes(rootVal, scaleIntervals) {
  return new Set(scaleIntervals.map(i => getNoteName((rootVal + i) % 12)));
}

function renderFretboard() {
  const fb = document.getElementById('fretboard');
  const lb = document.getElementById('labels');
  const tuningInput = document.getElementById('tuningInput').value.trim().toUpperCase();
  const tuningNotes = tuningInput.split(/\s+/).map(n => noteMap[n] ?? 4);
  const frets = parseInt(document.getElementById('fretsInput').value, 10) + 1;
  const notesInputEl = document.getElementById('notesInput');
  const highlightNotes = parseNotes(notesInputEl.value);
  const scaleRootName = document.getElementById('scaleRootSelect').value.toUpperCase();
  const scaleName = document.getElementById('scaleSelect').value;
  const hideNM = document.getElementById('hideNonMatchingToggle').checked;
  const highlightRootToggle = document.getElementById('highlightRootToggle').checked;

  const rootVal = noteMap[scaleRootName] ?? '';

  let scaleSet = new Set();
  if (scaleName && scales[scaleName]) {
    scales[scaleName].forEach(interval => {
      scaleSet.add(getNoteName((rootVal + interval) % 12));
    });
  }

  const highlightsSet = new Set(highlightNotes.map(n => n.toUpperCase()));
  if (scaleSet.size) {
    highlightsSet.forEach(note => scaleSet.add(note));
  }

  const strings = tuningNotes.slice().reverse();

  fb.innerHTML = '';
  fb.style.gridTemplateColumns = `repeat(${frets},80px)`;
  fb.style.gridTemplateRows = `repeat(${strings.length},50px)`;

  document.querySelectorAll('.string-line').forEach(e => e.remove());
  strings.forEach((_, i) => {
    const line = document.createElement('div');
    line.className = 'string-line';
    line.style.top = `${(i + 0.5) * 50}px`;
    line.style.height = i === 0 ? '3px' : '2px';
    fb.appendChild(line);
  });

  for (let s = 0; s < strings.length; s++) {
    for (let f = 0; f < frets; f++) {
      const openVal = strings[s];
      const noteIndex = (openVal + f) % 12;
      const noteName = getNoteName(noteIndex);
      const div = document.createElement('div');
      div.className = 'fret';
      div.dataset.fret = f;
      div.dataset.note = noteName;
      div.dataset.string = s;
      if (f === 0) div.classList.add('open');

      const isRoot = noteIndex === rootVal;
      const isScale = scaleSet.has(noteName);
      const isUserHighlight = highlightsSet.has(noteName);

      if (hideNM && f !== 0 && !isRoot && !isScale && !isUserHighlight) {
        div.textContent = '';
      } else {
        div.textContent = noteName;
      }

      if (isRoot && highlightRootToggle) {
        div.classList.add('root-highlight');
      } else if (isUserHighlight) {
        div.classList.add('highlight');
      } else if (isScale) {
        div.classList.add('scale-highlight');
      }

      div.addEventListener('click', () => {
        let currentNotes = parseNotes(notesInputEl.value);
        const clickedNote = noteName;
        const index = currentNotes.indexOf(clickedNote);
        if (index !== -1) {
          currentNotes.splice(index, 1);
        } else {
          currentNotes.push(clickedNote);
        }
        notesInputEl.value = currentNotes.join(' ');
        renderFretboard();
        analyzeHighlightedNotes();
      });

      fb.appendChild(div);
    }
  }

  lb.innerHTML = '';
  lb.style.gridTemplateColumns = `repeat(${frets},80px)`;
  for (let f = 0; f < frets; f++) {
    const D = document.createElement('div');
    D.textContent = f;
    lb.appendChild(D);
  }

  if (highlightNotes.length > 0) {
    analyzeHighlightedNotes();
  } else {
    document.getElementById('analysisOutput').textContent = "Select notes to see scale analysis automatically.";
  }
}

function analyzeHighlightedNotes() {
  const output = document.getElementById('analysisOutput');
  const highlightedNotes = new Set(parseNotes(document.getElementById('notesInput').value));

  if (highlightedNotes.size === 0) {
    output.textContent = "No highlighted notes selected.";
    return;
  }

  const results = new Map();

  for (let rootIndex = 0; rootIndex < 12; rootIndex++) {
    const rootName = getNoteName(rootIndex);
    for (const [scaleName, intervals] of window.scaleDefs) {
      const scaleNotesSet = getScaleNotes(rootIndex, intervals);
      const fits = [...highlightedNotes].every(note => scaleNotesSet.has(note));
      if (fits) {
        const key = [...scaleNotesSet].sort().join(',');
        const label = `${rootName} ${scaleName}`;
        if (!results.has(key)) results.set(key, []);
        results.get(key).push(label);
      }
    }
  }

  if (results.size === 0) {
    output.textContent = "No scale/root combinations contain all highlighted notes.";
  } else {
    output.innerHTML = `<strong>Scales containing all highlighted notes:</strong><br>`;
    const list = document.createElement('ul');
    for (const [noteSetKey, scales] of results.entries()) {
      const item = document.createElement('li');
      scales.sort();
      scales.forEach(label => {
        const [root, scale] = label.split(' ');
        const btn = document.createElement('button');
        btn.textContent = `${root} ${scale}`;
        btn.style.margin = '4px';
        btn.style.padding = '6px 10px';
        btn.style.background = '#444';
        btn.style.border = '1px solid #888';
        btn.style.color = '#fff';
        btn.style.borderRadius = '4px';
        btn.style.cursor = 'pointer';

        const scaleRootSelect = document.getElementById('scaleRootSelect');
        const scaleSelect = document.getElementById('scaleSelect');
        if (scaleRootSelect.value === root && scaleSelect.value === scale) {
          btn.classList.add('selected-scale');
        }

        btn.onclick = () => {
          if (
            scaleRootSelect.value === root &&
            scaleSelect.value === scale
          ) {
            scaleRootSelect.value = '';
            scaleSelect.value = '';
          } else {
            scaleRootSelect.value = root;
            scaleSelect.value = scale;
          }
          renderFretboard();
        };
        item.appendChild(btn);
      });
      list.appendChild(item);
    }
    output.appendChild(list);
  }
}

populateSelectors();
renderFretboard();

['notesInput','scaleRootSelect','scaleSelect','tuningInput','fretsInput','highlightRootToggle','hideNonMatchingToggle'].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  const eventType = (id === 'notesInput') ? 'input' : (id === 'highlightRootToggle' || id === 'hideNonMatchingToggle' || id === 'scaleRootSelect' || id === 'scaleSelect') ? 'change' : 'input';
  el.addEventListener(eventType, () => {
    renderFretboard();
    if (id === 'notesInput') analyzeHighlightedNotes();
  });
});
</script>

<style>
  #metrognomeBanner {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: #222;
    color: #eee;
    text-align: center;
    padding: 10px 0;
    font-weight: bold;
    font-family: sans-serif;
    box-shadow: 0 -2px 5px rgba(0,0,0,0.7);
    z-index: 1000;
  }
  #metrognomeBanner a {
    color: #4CAF50;
    text-decoration: none;
  }
  #metrognomeBanner a:hover {
    text-decoration: underline;
  }
</style>

<div id="metrognomeBanner">
  <a href="https://metrognome.necrosato.com/" target="_blank" rel="noopener noreferrer">
    Need a metrognome?
  </a>
</div>
</body>
</html>
